Проект "Криптокошелек".
Представьте: вы захотели купить криптовалюту.
Но сколько вы можете купить сегодня биткоинов за 100 000 рублей?
А сколько купленные биткоины будут стоить завтра?
Для того, чтобы вам не нужно было каждый день сидеть с калькулятором и ходить по сайтам
с целью поиска актуального курса для криптовалюты, мы создадим приложение, которое позволит:
- Вести учет сколько у нас есть криптовалютных монет
- Узнавать сколько сейчас стоит в долларах и рублях наши запасы криптовалют.

Этап №1 Работа с пользователями.
Для того, чтобы в нашем приложении люди могли пользоваться криптокошельком,
они должны иметь возможность регистрироваться в приложении.
1. Создать spring-boot проект (3.3.6 версия), в котором будут зависимости и плагины:
    lombok, spring-boot-starter-web, checkstyle(проверка на чекстайл тестового кода тоже).
    Для удобства можете использовать дополнительные библиотеки (при готовности обосновать зачем вы их использовали).
    GroupId: com.javaacademy, Artifact: cryptowallet, version 1:0:0. Приложение должно работать на порту 8008.

2. Создать сущность пользователь: логин, email, пароль.
3. Создать хранилище пользователей: хранит логин -> пользователь. Логин уникален.
3.1. Хранилище пользователей, позволяет:
3.1.1. Получать пользователей по логину
3.1.3. Сохранять нового пользователя. В случае, если пользователь с таким логином есть - вылетает ошибка.
4. Создать сервис по работе с пользователями (пользуется хранилищем). Сервис умеет:
4.1 Сохранять нового пользователя
4.2 Получать пользователя по логину. Если пользователь не найден, вылетает ошибка.
4.3 Сбрасывать пароль у пользователя. На вход логин, старый пароль, новый пароль:
4.3.1 Находит пользователя (пользуемся методом 4.3)
4.3.2 Сравнивает старый пароль с паролем у пользователя. Если не совпадают, выкидывает ошибку.
4.3.3 Ставит новый пароль найденному пользователю
5. Создать пользовательский контроллер, который:
5.1. По адресу POST /user/signup - регистрирует нового пользователя. Будет передаваться json с полями:
login, email, password.
5.2. По адресу POST /user/reset-password - сбрасывает пароль для существующего пользователя.
На вход json с полями: login, old_password, new_password.
Проверить работу через insomnia.

Этап №2 Создание криптосчетов у пользователей
После регистрации, человек должен иметь возможность создать криптосчет в определенной криптовалюте.
После создания счета можно менять его баланс.
1. Мы будем оперировать тремя криптовалютами в приложении:
BTC(полное название - bitcoin), ETH(ethereum), SOL(solana)
2. Создать сущность криптосчет: логин владельца, криптовалюта счета, сколько криптовалюты на счету,
уникальный номер счета UUID.

3. Создать сущность хранилище криптосчетов. Хранит: uuid -> криптосчет:
3.1 Умеет сохранять счет. Если с таким uuid есть счет, то ошибка.
3.2 Умеет отдавать счет по uuid.
3.3. Умеет отдавать все счета пользователя. На вход логин пользователя, на выход все счета пользователя.

4. Создать сервис криптосчетов. Сервис умеет:
4.1. Находить счет по uuid. Если счета нет, то выкидывает ошибку.
4.2. Возвращать все счета пользователя. Если такого пользователя нет, выкидываем ошибку.
4.3. Создавать криптосчет для пользователя. На вход логин пользователя и тип валюты. 
4.3.1 Находим пользователя, если пользователя нет, выкидываем ошибку.
4.3.2 Создаем счет, у которого количество валюты 0, тип валюты из аргументов,
уникальный номер проставляется UUID.randomUUID()
4.3.3 Сохраняем в хранилище счетов.

5. Создать контроллер для операций по криптосчетам, который:
5.1 по адресу POST /cryptowallet создает счет. Будет передаваться json с полями:
    username, crypto_type. Ожидается, что в crypto_type должен находиться один из 3 типов криптовалют (пункт 1.).
    Если значение другое, то мы должны выбросить ошибку. Данный endpoint должен вызывать создание счета (пункт 4.3).
Возвращает сгенерированный UUID нового счета.
5.2 по адресу GET /cryptowallet?username=[значение] - мы должны будем получить список счетов пользователя (пункт 4.2).
Проверить работу через insomnia.

Этап №3 Получение эквивалентов в долларах.
На этом этапе, мы должны научиться менять баланс криптосчетов.
Так же необходимо узнать, сколько денег на наших счетах в рублях и долларах.
1. Подключим новые библиотеки:
- Для отправки http запросов https://mvnrepository.com/artifact/com.squareup.okhttp3/okhttp/4.12.0
- Для работы с json https://mvnrepository.com/artifact/com.jayway.jsonpath/json-path/2.9.0
2. Для получения данных, мы будем спользовать www.coingecko.com (адрес api - https://api.coingecko.com/api/v3).
При использовании этого сайта, нам нужно указывать токен, который генерируется для пользователей сайта.
Во время отправки запроса будем добавлять заголовок x_cg_demo_api_key со значением xCVqoMDWXQpoSpqNTCshp5Ua.
Вынести адрес сайта, наименование заголовка и токен в yaml.
3. Необходимо создать сервис который будет отвечать за получение стоимости криптовалют в долларах.
Внутри сервиса будет использован экземпляр класса OkHttpClient.
3.1 Создать метод получения стоимости криптовалюты в долларах.
3.1.1. Для получения стоимости криптовалюты делаем запрос
GET  [адрес api coingecko] + /simple/price?ids=[полное название криптовалюты]&vs_currencies=usd.
Не забудьте добавить заголовок и токен. В результате получим ответ (resonse)
3.1.2. Нам нужно проверить что статус ответа успешный (response.isSuccessful()) и тело ответа не пустое.
Если одно из двух условий не выполнится, должна вылететь ошибка.
3.1.3. Тело успешного ответа будет выглядеть примерно так (bitcoin - может смениться на ethereum или solana):
{
	"bitcoin": {
		"usd": 96703
	}
}
Нам необходимо вытащить полученную стоимость криптовалюты - 96703 (путь $.bitcoin.usd).
Для получения стоимости воспользуемся классами библиотеки JsonPath.
JsonPath позволяет указать путь до конкретного значения и получить это значение из json данных.
3.1.3.1. Создадим путь по которому будем искать значение.
Необходимо сформировать строку следующего формата:
$['[имя криптовалюты]']['usd']. Например для bitcoin путь будет $['bitcoin']['usd'].
3.1.3.2. Из пришедшего ответа достанем значение и вернем его в качестве работы метода:
JsonPath.parse([данные из тела ответа]).read(JsonPath.compile([путь до значения]),
[К какому классу мы скастить результат]).
Подумайте какой класс отвечает за точные денежные вычисления.
4. Чтобы вы не прожигали деньги за использование api, данный сервис должен запускаться только под профилем "prod"
5. Создайте сервис заглушку для локального использования. Сервис будет возвращать 10_000 при запросе любой валюты.
Должен запускаться под профилем "local". Возвращаемое значение заглушки (10_000) должны быть проперти в соответствующем yaml.

Этап №4 Получение рублевого эквивалента стоимости криптовалют и 
В этом этапе мы хотим покупать и продавать наши криптовалюты за рубли, меняя баланс наших счетов.
Создадим новый сервис интеграции, который будет (существует при профиле "prod"):
1. Умеет конвертировать доллар в рубли. На вход количество долларов, на выход количество рублей.
1.1 Необходимо отправить запрос в Центральный банк РФ и получать от туда курс рубль доллар
(сколько долларов можно купить за 1 рубль). Отправьте GET запрос https://www.cbr-xml-daily.ru/latest.js
и в полученном ответе вытащите значение $.rates.USD, заполнять заголовки не надо.
1.2 Результатом метода будет количетсво долларов деленное на данный курс.
2 Умеет конвертировать рубли в доллар. На вход количество рублей, на выход количество долларов.
Тоже самое что пункт 1.1, только вместо деления из 1.1.2 - умножение.
2. Создать сервис заглушку, который конвертирует доллар в рубль  по курсу 1 доллар = 100 рублей.
Должен запускаться при профиле "local". Возвращаемое значение заглушки (100) должны быть проперти в соответствующем yaml.

Этап №5 Изменение баланса криптосчета
Нам необходимо добавить в сервис криптосчетов (Этап №2 пункт 4) функции покупки, продажи криптовалют за рубли.
Так же нужно отображать рублевые эквиваленты криптосчетов.
Создадим методы:
1. Пополнять счет на рубли: на вход номер криптосчета, сумма рублей. Метод ничего не возвращает.
1.1 Находим счет из хранилища криптосчетов. Если нет, выбрасываем ошибку.
1.2 Из счета вытаскиваем тип криптовалюты. 
1.3 Получаем текущий курс криптовалюты в долларах (этап 3 пункт 3.1.)
1.4 Конвертируем рублевую сумму в доллары с помощью сервиса из пункта 1.
1.5 Делим получившееся количество долларов(1.4) на курс криптовалюты(1.3)
1.6 Прибавляем полученную сумму к текущему криптовалютному счету.
2. Снимать рубли со счета: на вход номер криптосчета, сумма рублей которые хотим снять. 
2.1 Повторяем пункты 1.1 - 1.5. 
2.2 Списываем полученную сумму с криптовалютного счета. Если у счета нет столько криптовалюты, должна вылететь ошибка. 
2.3 Возвращаем текст: "Операция прошла успешно. Продано [количество проданной криптовалюты] [наименование криптовалюты]."
3. Показывать рублевый эквивалент остатка счета: на вход номер счета. на выход рублевый эквивалент остатка. Использовать метода 1.1 - 1.5
4. Показывать рублевый эквивалент остатка всех счетов пользователя. На вход имя пользователя, на выход сумма рублевого эквивалента всех счетов.
Получаем все счета пользователя, после применяем к каждому пункт 3. Суммируем результаты.
5. Добавить методы в контроллер криптовалют (этап №2 пункт 5):
5.1 по адресу POST /cryptowallet/refill пополняет счет. В теле запроса будет account_id (id криптосчета) и rubles_amount (сумма рублей).
5.2 по адресу POST /cryptowallet/withdrawal снимает рубли со счета. В теле запроса будет номер account_id (id криптосчета) и rubles_amount (сумма рублей).
5.3 по адресу GET /cryptowallet/balance/{id} - показывает рублевый эквивалент криптосчета. id - номер криптосчета
5.4 по адресу GET /cryptowallet/balance?username={login} - показывает рублевый эквивалент суммы со всех криптосчетов пользователя. 
 
Этап №6. Описание api приложения.
1. Необходимо подключить swagger к приложению - https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-starter-webmvc-ui/2.6.0
2. Описать все контроллеры и их методы (этап №1 пункт 5, этап №2 пункт 5, этап №5 пункт 5) используя swagger аннотации.

Этап №7. Покрытие тестами приложения.
1. Необходимо подключить тестовую библиотеку rest-assured https://mvnrepository.com/artifact/io.rest-assured/rest-assured/5.4.0
2. Покрыть тестами все методы контроллеров, отправляя запросы через rest-assured.
